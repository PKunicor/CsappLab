先记录一下做题思路,后面再改成markdown格式
phase1:
第一个比较简单,找到字符串对比函数,参数1放在寄存器rdi里,参数2放在寄存器rsi里
用gdb打断点,命令x/1sb $rsi,打印出内存里的字符串内容
答案:
Border relations with Canada have never been better.

phase2:
第二个主要是是在函数分配的栈里面进行操作,通过sscanf函数的第二个参数,format,"%d %d %d %d %d %d",
可以看出密码应该是六个数,通过记录的rsi是phase2函数的rsp,可以知道最终密码应该是保存在主函数的栈区,第一次和1比较,相同才能继续,第一个数字是1, 后面每一个数字都是和前一个数字*2相比较,那么就是一个等比数列,公比2,
答案:
1 2 4 8 16 32

phase3:
第三个和第二个相同,查看输入的是两个%d,存在phase3的栈里面,不一样的地方是,这道题目的答案有7种,因为第一个密码小于7,所有一共有7组答案,分别是0,207,   1-0x137,2-0x2c3,3-0x100,4-0x185,5-0xce, 6-0x2aa.
答案:
0 207

phase4
第四个主要难点在func4函数里有一个单操作数的sar指令,之前一直以为移位的数存在寄存器cl里,后来才发现这是默认移位1,所有这个题的密码第一位是在用二分法在(0-14)中找值,但是由于函数返回值是0才不会爆炸,往右半部分查找时,返回值不为0,所以密码只能在左半部分,分别是7,3,1,0,四种答案,第二个密码是在phase_4函数里,对比的数字是0,所以第二个密码是0
答案:
0 0

phase5
第五个比较有趣,还是和12一样计算字符串长度,知道密码应该是一个6位长度字符串,计算字符串是不是相等函数的参数显示待匹配的字符串是"flyers", 编译的时候用了canary,这个对解密应该是没影响,主要是输入的字符串,每一个字节只保留了低四位,然后加上一个地址,将内存中的值送到了rsp里,那么这个地址应该是一个数组,打印一下这个地址开始的15个字节,是一串字符maduiersnfotvbyl,在这个字符串数组中,找出对应的"flyers",位置分别是9,15,14,5,6,7.所以输入的字符串的ASCII编码后四位应该就是这个值,答案比较多,找了一个'a'-'z'中的答案,
答案:
ionefg

phase6
第六个是一个链表,节点的前八个字节中低位是数据,高位是输入的密码,高位的8个字节是下一跳地址,根据输入的6个数必须是1-6,切两两不相同,还进行了一次处理,每一位密码x,变成了y = 7-x.
然后是链表的操作,每一个密码的节点对应的是(y - 1) * 8 + 结点首地址,  分配好结点后进行结点连接
每一位密码的下一跳就是下一位密码对应的结点地址,最后一位结点的下一跳是0;
要求是必要让结点中的数据,满足前一个结点大于等于后一个结点,
而所有结点的数据分别是:
(1):332
(2):168
(3):924
(4):691
(5):477
(6):443
所以数据最大的结点应该在最前面,序号应该是3 4 5 6 1 2
而输入的密码应该是7 - y;   4 3 2 1 6 5
答案:
4 3 2 1 6 5

Border relations with Canada have never been better.
1 2 4 8 16 32
0 207
0 0
ionefg
4 3 2 1 6 5
